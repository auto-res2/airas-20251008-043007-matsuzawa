
Input:
You are a researcher with expertise in engineering in the field of machine learning.

# Instructions
- The content described in “Repository Content” corresponds to the GitHub repository of the method described in “Method.”
- Please extract the following two pieces of information from “Repository Content”:
    - experimental_code：Extract the implementation sections that are directly related to the method described in “Method.”
    - experimental_info：Extract and output the experimental settings related to the method described in “Method.”

# Method
Active inference operates on the intuition of prioritizing labels for data points where the machine learning model is uncertain and relying on model predictions where it is confident. The core mechanism is based on Augmented Inverse Propensity Weighting (AIPW) estimators for mean estimation and a general M-estimation framework for other targets. A key component is the sampling rule, π(x), which determines the probability of labeling an instance x. This rule is derived from a measure of model uncertainty, u(x). For regression, u(x) is trained to predict the magnitude of the model error, |f(X)-Y|, while for classification (e.g., binary), it's based on predictive probabilities (e.g., 2 * min{p(x), 1-p(x)}). The sampling rule is calibrated to meet a given budget `nb` by scaling `π(x) = u(x) * nb / (n * E[u(X)])`. In the batch setting, a pre-trained model and fixed sampling rule are used. In the sequential setting, the model and sampling rule are iteratively updated as new labels are collected, respecting a martingale structure for tractable inference. Practical sampling rules stabilize the `u(x)`-based rule by mixing it with a uniform sampling rule (`πunif = nb/n`) using a parameter `τ` (e.g., `π(τ)(x) = (1-τ)π(x) + τπunif(x)`) to prevent instability from near-zero uncertainty estimates.

# Repository Content
File Path: utils.py
Content:
import os
import sys
sys.path.insert(1, '../')
import numpy as np
import folktables
import pdb
import matplotlib.pyplot as plt
import matplotlib.patheffects as pe
import seaborn as sns
import pandas as pd

import scipy
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from matplotlib.ticker import FormatStrFormatter
from matplotlib.ticker import LogLocator
from matplotlib.ticker import ScalarFormatter
from matplotlib.ticker import NullFormatter

def get_data(year,features,outcome, randperm=True):
    # Predict income and regress to time to work
    data_source = folktables.ACSDataSource(survey_year=year, horizon='1-Year', survey='person')
    acs_data = data_source.get_data(states=["CA"], download=True)
    income_features = acs_data[features].fillna(-1)
    income = acs_data[outcome].fillna(-1)
    employed = np.isin(acs_data['COW'], np.array([1,2,3,4,5,6,7]))
    if randperm:
        shuffler = np.random.permutation(income.shape[0])
        income_features, income, employed = income_features.iloc[shuffler], income.iloc[shuffler], employed[shuffler]
    return income_features, income, employed

def transform_features(features, ft, enc=None):
    c_features = features.T[ft == "c"].T.astype(str)
    if enc is None:
        enc = OneHotEncoder(handle_unknown='ignore', drop='if_binary', sparse=False)
        enc.fit(c_features)
    c_features = enc.transform(c_features)
    features = scipy.sparse.csc_matrix(np.concatenate([features.T[ft == "q"].T.astype(float), c_features], axis=1))
    return features, enc

def ols(features, outcome):
    ols_coeffs = np.linalg.pinv(features).dot(outcome)
    return ols_coeffs

def lighten_color(color, amount=0.5):
    """
    Lightens the given color by multiplying (1-luminosity) by the given amount.
    Input can be matplotlib color string, hex string, or RGB tuple.

    Examples:
    >> lighten_color('g', 0.3)
    >> lighten_color('#F034A3', 0.6)
    >> lighten_color((.3,.55,.1), 0.5)
    """
    import matplotlib.colors as mc
    import colorsys
    try:
        c = mc.cnames[color]
    except:
        c = color
    c = colorsys.rgb_to_hls(*mc.to_rgb(c))
    return colorsys.hls_to_rgb(c[0], 1 - amount * (1 - c[1]), c[2])


def make_width_coverage_plot(df, estimand_title, filename, theta_true, alpha = 0.1, n_l = 0, n_u = np.inf, num_trials = 100, n_example_ind = 0, finetuning=False, more_precision=False, less_precision=False):
    num_ints = 5
    inds = np.random.choice(num_trials, num_ints)
    ns = df["$n_b$"].unique()
    estimators = df["estimator"].unique()
    n_example = ns[n_example_ind]
    ints = [ [] for _ in range(len(estimators)) ]
    widths = np.zeros((len(estimators), len(ns)))

    # compute example intervals and average widths
    for i in range(len(estimators)):
        for j in range(len(ns)):
            widths[i,j] = df[(df.estimator == estimators[i]) & (df["$n_b$"] == ns[j])]['interval width'].mean()
    
        for j in range(num_ints):
            ind = inds[j]
            ints[i].append([df[(df.estimator == estimators[i]) & (df['$n_b$'] == n_example)].iloc[ind].lb, df[(df.estimator == estimators[i]) & (df['$n_b$'] == n_example)].iloc[ind].ub])

    n_l = n_l
    n_u = n_u
    inds_n = np.where((ns>n_l) & (ns<n_u))[0] # budget indices that will be plotted
    x_ticks = np.logspace(np.log10(min(df['$n_b$'][(df['$n_b$'] > n_l)])), np.log10(max(df['$n_b$'][(df['$n_b$'] < n_u)])), num=5) # adjust 'num' for more/less ticks
    x_ticks = [int(x) for x in x_ticks]
    y_ticks = np.logspace(np.log10(np.min(widths[:,inds_n[-1]])), np.log10(np.max(widths[:,inds_n[0]])), num=5) # adjust 'num' for more/less ticks

    # plotting params
    gap = 0.03
    start1 = 0.5
    start2 = 0.35
    start3 = 0.2
    linewidth_inner = 5
    linewidth_outer = 7
    col = [sns.color_palette("pastel")[1], sns.color_palette("pastel")[2], sns.color_palette("pastel")[0]]
    if finetuning:
        col = [sns.color_palette("pastel")[1], sns.color_palette("pastel")[0], sns.color_palette("pastel")[2]]
    sns.set_theme(font_scale=1.5, style='white', palette=col, rc={'lines.linewidth': 3})
    if finetuning:
        fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(18,3.3))
    else:
        fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(15,3.3))
    sns.lineplot(ax=axs[1],data=df[(df['$n_b$'] > n_l) & (df['$n_b$'] < n_u)], x='$n_b$', y='interval width', hue='estimator', alpha=0.8)
    sns.lineplot(ax=axs[2],data=df[(df['$n_b$'] > n_l) & (df['$n_b$'] < n_u)], x='$n_b$', y='coverage', hue='estimator', alpha=0.8, errorbar=None)

    axs[0].axvline(theta_true, color='gray', linestyle='dashed')
    for i in reversed(range(num_ints)):
        if i == 0:
            axs[0].plot([ints[0][i][0] , ints[0][i][1] ],[start1+i*gap,start1+i*gap], linewidth=linewidth_inner, color=lighten_color(col[0],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[0]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[0]), pe.Normal()],  solid_capstyle='butt')
            axs[0].plot([ints[1][i][0] , ints[1][i][1] ],[start2+i*gap, start2+i*gap], linewidth=linewidth_inner, color=lighten_color(col[1],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[1]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[1]), pe.Normal()],  solid_capstyle='butt')
            axs[0].plot([ints[2][i][0] , ints[2][i][1] ],[start3+i*gap, start3+i*gap], linewidth=linewidth_inner, color=lighten_color(col[2],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[2]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[2]), pe.Normal()],  solid_capstyle='butt')
        if i > 0:
            axs[0].plot([ints[0][i][0], ints[0][i][1]],[start1+i*gap,start1+i*gap], linewidth=linewidth_inner, color= lighten_color(col[0],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[0]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[0]), pe.Normal()], solid_capstyle='butt')
            axs[0].plot([ints[1][i][0] , ints[1][i][1]],[start2+i*gap, start2+i*gap], linewidth=linewidth_inner, color=lighten_color(col[1],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[1]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[1]), pe.Normal()], solid_capstyle='butt')
            axs[0].plot([ints[2][i][0] , ints[2][i][1]],[start3+i*gap, start3+i*gap], linewidth=linewidth_inner, color=lighten_color(col[2],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[2]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[2]), pe.Normal()], solid_capstyle='butt')
    axs[0].set_xlabel(estimand_title, fontsize=16)
    axs[0].set_yticks([])
    
    axs[1].get_legend().remove()
    axs[1].set(xscale='log', yscale='log')
    axs[1].set_xticks(x_ticks)
    axs[1].set_yticks(y_ticks)
    axs[1].xaxis.set_minor_formatter(NullFormatter())
    axs[1].yaxis.set_minor_formatter(NullFormatter())
    axs[1].get_xaxis().set_major_formatter(ScalarFormatter())
    axs[1].get_yaxis().set_major_formatter(ScalarFormatter())
    axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    if more_precision:
        axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.3f'))
    if less_precision:
        axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.0f'))
    axs[1].grid(True)
    
    axs[2].axhline(1-alpha, color="#888888", linestyle='dashed', zorder=1, alpha=0.8)
    handles, labels = axs[2].get_legend_handles_labels()
    if finetuning:
        axs[2].legend(handles=handles, labels=labels, loc='lower right', bbox_to_anchor=(1.9, 0.43))
    else:
        axs[2].legend(handles=handles, labels=labels, loc='lower right', bbox_to_anchor=(1.6, 0.43))
    axs[2].set_ylim([0.6,1])
    x_ticks_coverage = np.linspace(np.min(ns[ns>n_l]), np.max(ns[ns<n_u]), 5)
    x_ticks_coverage = [int(x) for x in x_ticks_coverage]
    axs[2].set_xticks(x_ticks_coverage)
    axs[2].set_xlim([np.min(ns[ns>n_l]), np.max(ns[ns<n_u])])
    axs[2].grid(True)
    
    sns.despine(top=True, right=True)
    sns.despine(left=True, ax = axs[0])
    plt.tight_layout()
    
    # save plot
    plt.savefig(filename)
    plt.show()


def make_budget_plot(df, plot_title, filename, finetuning=False, include_ylabel=True):
    ns = df["$n_b$"].unique()
    estimators = df["estimator"].unique()
    widths = np.zeros((len(estimators), len(ns)))

    # compute average widths
    for i in range(len(estimators)):
        for j in range(len(ns)):
            widths[i,j] = df[(df.estimator == estimators[i]) & (df["$n_b$"] == ns[j])]['interval width'].mean() 
            
    save1 = []
    save2 = []

    ns_large1 = ns[np.where(widths[0,0] > widths[1,:])]
    for n in ns_large1:
        target_width = df[(df.estimator == estimators[1]) & (df["$n_b$"] == n)]['interval width'].mean()
        active_0 = np.where(np.array(widths[0,:]) > target_width)[0][-1]
        active_1 = active_0 + 1
        # linearly interpolate:
        active_n = round((widths[0,active_0] - target_width)/(widths[0,active_0] - widths[0,active_1])*(ns[active_1] - ns[active_0]) + ns[active_0])
        save1.append((n - active_n)/n*100)

    ns_large2 = ns[np.where(widths[0,0] > widths[2,:])]
    for n in ns_large2:
        target_width = df[(df.estimator == estimators[2]) & (df["$n_b$"] == n)]['interval width'].mean()
        active_0 = np.where(np.array(widths[0,:]) > target_width)[0][-1]
        active_1 = active_0 + 1
        # linearly interpolate:
        active_n = round((widths[0,active_0] - target_width)/(widths[0,active_0] - widths[0,active_1])*(ns[active_1] - ns[active_0]) + ns[active_0])
        save2.append((n - active_n)/n*100)


    col = [sns.color_palette("pastel")[1]]
    sns.set_theme(font_scale=1.7, style='white', palette=col, rc={'lines.linewidth': 3})
    fig, axs = plt.subplots(nrows=2, ncols=1, figsize=(6,6))

    y_ticks = [0, 25, 50, 75, 100]
    
    axs[0].set_title(plot_title)
    axs[0].plot(ns_large1, save1, marker="o", markersize=8, linestyle='dashed', alpha=0.8)
    axs[0].set_xlabel('$n_b$')
    axs[0].set_ylim([0,100])
    axs[0].set_yticks(y_ticks)
    if include_ylabel:
        if finetuning:
            axs[0].set_ylabel('budget save over\n no fine-tuning (%)')
        else:
            axs[0].set_ylabel('budget save\n over classical (%)')
    axs[0].get_yaxis().set_major_formatter(FormatStrFormatter('%.0f'))
    axs[0].grid(True)

    axs[1].plot(ns_large2, save2, marker="o", markersize=8, linestyle='dashed', alpha=0.8)
    axs[1].set_xlabel('$n_b$')
    axs[1].set_ylim([0,100])
    axs[1].set_yticks(y_ticks)
    if include_ylabel:
        axs[1].set_ylabel('budget save\n over uniform (%)')
    axs[1].get_yaxis().set_major_formatter(FormatStrFormatter('%.0f'))
    axs[1].grid(True)

    # xticks_locations = axs[1].get_xticks()
    # xlim = axs[1].get_xlim()
    # axs[0].set_xticks(xticks_locations)
    # axs[0].set_xlim(xlim)
    # axs[1].set_xticks(xticks_locations)
    # axs[1].set_xlim(xlim)

    sns.despine(top=True, right=True)
    plt.tight_layout()
    
    # save plot
    plt.savefig(filename)
    plt.show()
    return fig, axs
Output:
{
    "experimental_code": "def ols(features, outcome):\n    ols_coeffs = np.linalg.pinv(features).dot(outcome)\n    return ols_coeffs\ndef make_width_coverage_plot(df, estimand_title, filename, theta_true, alpha = 0.1, n_l = 0, n_u = np.inf, num_trials = 100, n_example_ind = 0, finetuning=False, more_precision=False, less_precision=False):\n    num_ints = 5\n    inds = np.random.choice(num_trials, num_ints)\n    ns = df[\"$n_b$\"].unique()\n    estimators = df[\"estimator\"].unique()\n    n_example = ns[n_example_ind]\n    ints = [ [] for _ in range(len(estimators)) ]\n    widths = np.zeros((len(estimators), len(ns)))\n\n    for i in range(len(estimators)):\n        for j in range(len(ns)):\n            widths[i,j] = df[(df.estimator == estimators[i]) & (df[\"$n_b$\"] == ns[j])]['interval width'].mean()\n    \n        for j in range(num_ints):\n            ind = inds[j]\n            ints[i].append([df[(df.estimator == estimators[i]) & (df['$n_b$'] == n_example)].iloc[ind].lb, df[(df.estimator == estimators[i]) & (df['$n_b$'] == n_example)].iloc[ind].ub])\n\n    n_l = n_l\n    n_u = n_u\n    inds_n = np.where((ns>n_l) & (ns<n_u))[0]\n    x_ticks = np.logspace(np.log10(min(df['$n_b$'][(df['$n_b$'] > n_l)])), np.log10(max(df['$n_b$'][(df['$n_b$'] < n_u)])), num=5)\n    x_ticks = [int(x) for x in x_ticks]\n    y_ticks = np.logspace(np.log10(np.min(widths[:,inds_n[-1]])), np.log10(np.max(widths[:,inds_n[0]])), num=5)\n\n    gap = 0.03\n    start1 = 0.5\n    start2 = 0.35\n    start3 = 0.2\n    linewidth_inner = 5\n    linewidth_outer = 7\n    col = [sns.color_palette(\"pastel\")[1], sns.color_palette(\"pastel\")[2], sns.color_palette(\"pastel\")[0]]\n    if finetuning:\n        col = [sns.color_palette(\"pastel\")[1], sns.color_palette(\"pastel\")[0], sns.color_palette(\"pastel\")[2]]\n    sns.set_theme(font_scale=1.5, style='white', palette=col, rc={'lines.linewidth': 3})\n    if finetuning:\n        fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(18,3.3))\n    else:\n        fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(15,3.3))\n    sns.lineplot(ax=axs[1],data=df[(df['$n_b$'] > n_l) & (df['$n_b$'] < n_u)], x='$n_b$', y='interval width', hue='estimator', alpha=0.8)\n    sns.lineplot(ax=axs[2],data=df[(df['$n_b$'] > n_l) & (df['$n_b$'] < n_u)], x='$n_b$', y='coverage', hue='estimator', alpha=0.8, errorbar=None)\n\n    axs[0].axvline(theta_true, color='gray', linestyle='dashed')\n    for i in reversed(range(num_ints)):\n        if i == 0:\n            axs[0].plot([ints[0][i][0] , ints[0][i][1] ],[start1+i*gap,start1+i*gap], linewidth=linewidth_inner, color=lighten_color(col[0],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[0]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[0]), pe.Normal()],  solid_capstyle='butt')\n            axs[0].plot([ints[1][i][0] , ints[1][i][1] ],[start2+i*gap, start2+i*gap], linewidth=linewidth_inner, color=lighten_color(col[1],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[1]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[1]), pe.Normal()],  solid_capstyle='butt')\n            axs[0].plot([ints[2][i][0] , ints[2][i][1] ],[start3+i*gap, start3+i*gap], linewidth=linewidth_inner, color=lighten_color(col[2],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[2]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[2]), pe.Normal()],  solid_capstyle='butt')\n        if i > 0:\n            axs[0].plot([ints[0][i][0], ints[0][i][1]],[start1+i*gap,start1+i*gap], linewidth=linewidth_inner, color= lighten_color(col[0],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[0]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[0]), pe.Normal()], solid_capstyle='butt')\n            axs[0].plot([ints[1][i][0] , ints[1][i][1]],[start2+i*gap, start2+i*gap], linewidth=linewidth_inner, color=lighten_color(col[1],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[1]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[1]), pe.Normal()], solid_capstyle='butt')\n            axs[0].plot([ints[2][i][0] , ints[2][i][1]],[start3+i*gap, start3+i*gap], linewidth=linewidth_inner, color=lighten_color(col[2],0.6), path_effects=[pe.Stroke(linewidth=linewidth_outer, offset=(-1,0), foreground=col[2]), pe.Stroke(linewidth=linewidth_outer, offset=(1,0), foreground=col[2]), pe.Normal()], solid_capstyle='butt')\n    axs[0].set_xlabel(estimand_title, fontsize=16)\n    axs[0].set_yticks([])\n    \n    axs[1].get_legend().remove()\n    axs[1].set(xscale='log', yscale='log')\n    axs[1].set_xticks(x_ticks)\n    axs[1].set_yticks(y_ticks)\n    axs[1].xaxis.set_minor_formatter(NullFormatter())\n    axs[1].yaxis.set_minor_formatter(NullFormatter())\n    axs[1].get_xaxis().set_major_formatter(ScalarFormatter())\n    axs[1].get_yaxis().set_major_formatter(ScalarFormatter())\n    axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.2f'))\n    if more_precision:\n        axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.3f'))\n    if less_precision:\n        axs[1].yaxis.set_major_formatter(FormatStrFormatter('%.0f'))\n    axs[1].grid(True)\n    \n    axs[2].axhline(1-alpha, color=\"#888888\", linestyle='dashed', zorder=1, alpha=0.8)\n    handles, labels = axs[2].get_legend_handles_labels()\n    if finetuning:\n        axs[2].legend(handles=handles, labels=labels, loc='lower right', bbox_to_anchor=(1.9, 0.43))\n    else:\n        axs[2].legend(handles=handles, labels=labels, loc='lower right', bbox_to_anchor=(1.6, 0.43))\n    axs[2].set_ylim([0.6,1])\n    x_ticks_coverage = np.linspace(np.min(ns[ns>n_l]), np.max(ns[ns<n_u]), 5)\n    x_ticks_coverage = [int(x) for x in x_ticks_coverage]\n    axs[2].set_xticks(x_ticks_coverage)\n    axs[2].set_xlim([np.min(ns[ns>n_l]), np.max(ns[ns<n_u])])\n    axs[2].grid(True)\n    \n    sns.despine(top=True, right=True)\n    sns.despine(left=True, ax = axs[0])\n    plt.tight_layout()\n    \n    plt.savefig(filename)\n    plt.show()\ndef make_budget_plot(df, plot_title, filename, finetuning=False, include_ylabel=True):\n    ns = df[\"$n_b$\"].unique()\n    estimators = df[\"estimator\"].unique()\n    widths = np.zeros((len(estimators), len(ns)))\n\n    for i in range(len(estimators)):\n        for j in range(len(ns)):\n            widths[i,j] = df[(df.estimator == estimators[i]) & (df[\"$n_b$\"] == ns[j])]['interval width'].mean() \n            \n    save1 = []\n    save2 = []\n\n    ns_large1 = ns[np.where(widths[0,0] > widths[1,:])]\n    for n in ns_large1:\n        target_width = df[(df.estimator == estimators[1]) & (df[\"$n_b$\"] == n)]['interval width'].mean()\n        active_0 = np.where(np.array(widths[0,:]) > target_width)[0][-1]\n        active_1 = active_0 + 1\n        active_n = round((widths[0,active_0] - target_width)/(widths[0,active_0] - widths[0,active_1])*(ns[active_1] - ns[active_0]) + ns[active_0])\n        save1.append((n - active_n)/n*100)\n\n    ns_large2 = ns[np.where(widths[0,0] > widths[2,:])]\n    for n in ns_large2:\n        target_width = df[(df.estimator == estimators[2]) & (df[\"$n_b$\"] == n)]['interval width'].mean()\n        active_0 = np.where(np.array(widths[0,:]) > target_width)[0][-1]\n        active_1 = active_0 + 1\n        active_n = round((widths[0,active_0] - target_width)/(widths[0,active_0] - widths[0,active_1])*(ns[active_1] - ns[active_0]) + ns[active_0])\n        save2.append((n - active_n)/n*100)\n\n\n    col = [sns.color_palette(\"pastel\")[1]]\n    sns.set_theme(font_scale=1.7, style='white', palette=col, rc={'lines.linewidth': 3})\n    fig, axs = plt.subplots(nrows=2, ncols=1, figsize=(6,6))\n\n    y_ticks = [0, 25, 50, 75, 100]\n    \n    axs[0].set_title(plot_title)\n    axs[0].plot(ns_large1, save1, marker=\"o\", markersize=8, linestyle='dashed', alpha=0.8)\n    axs[0].set_xlabel('$n_b$')\n    axs[0].set_ylim([0,100])\n    axs[0].set_yticks(y_ticks)\n    if include_ylabel:\n        if finetuning:\n            axs[0].set_ylabel('budget save over\\n no fine-tuning (%)')\n        else:\n            axs[0].set_ylabel('budget save\\n over classical (%)')\n    axs[0].get_yaxis().set_major_formatter(FormatStrFormatter('%.0f'))\n    axs[0].grid(True)\n\n    axs[1].plot(ns_large2, save2, marker=\"o\", markersize=8, linestyle='dashed', alpha=0.8)\n    axs[1].set_xlabel('$n_b$')\n    axs[1].set_ylim([0,100])\n    axs[1].set_yticks(y_ticks)\n    if include_ylabel:\n        axs[1].set_ylabel('budget save\\n over uniform (%)')\n    axs[1].get_yaxis().set_major_formatter(FormatStrFormatter('%.0f'))\n    axs[1].grid(True)\n\n    sns.despine(top=True, right=True)\n    plt.tight_layout()\n    \n    plt.savefig(filename)\n    plt.show()\n    return fig, axs",
    "experimental_info": "Data Source: Folktables ACSDataSource with `horizon='1-Year'`, `survey='person'`, and `states=[\"CA\"]`. The survey year, features, and outcome are configurable parameters.\nExperimental Settings for Plotting (from `make_width_coverage_plot`):\n- Confidence level for coverage plots: `alpha = 0.1` (used to draw `1-alpha` line).\n- Budget range for plotting: `n_l = 0`, `n_u = np.inf` (default, actual range based on data).\n- Number of trials simulated for interval calculation: `num_trials = 100`.\n- `finetuning` flag: `False` by default in both plotting functions, likely indicating whether sequential updates (fine-tuning of the model and sampling rule) are active or if a fixed, batch setting is used.\nComparison:\n- Plots are generated for different \"estimators\" (active learning strategies), comparing interval width, coverage, and budget savings. This implies comparing active inference against at least two other methods, referred to as \"classical\" and \"uniform\" sampling in `make_budget_plot`."
}
